## ROS 2 Services: Request-Response Communication

üí¨ **Theory Insight: Synchronous Interaction in ROS 2**

While ROS 2 topics are ideal for streaming continuous, asynchronous data, many robotic tasks require a direct, synchronous request-response interaction. For these scenarios, ROS 2 provides *services*. Services allow a client node to send a request to a service server node and wait for a single, immediate response. This communication pattern is analogous to a function call in a distributed system.

Key components of ROS 2 services:

-   **Service Server**: A node that offers a specific service. It listens for incoming requests, processes them, and sends back a response. For example, a robot arm node might offer a service to `set_joint_angle`.
-   **Service Client**: A node that sends a request to a service server and blocks (waits) until it receives a response. For example, a high-level planning node might act as a client to request a robot arm to move.
-   **Service Type**: Defines the structure of both the request and the response messages. Each service has a unique service type (e.g., `std_srvs/srv/SetBool`, `example_interfaces/srv/AddTwoInts`).
-   **Service Name**: A unique identifier for the service within the ROS graph (e.g., `/robot/set_joint_angle`).

Services are crucial for commands that require an immediate acknowledgment or a single data point in return, such as triggering an action, querying a specific robot state, or performing a calculation. They ensure that an operation is completed before the client proceeds, which is vital for sequential task execution in robotics.

### ROS 2 Service Communication

```mermaid
graph TD
    Client[Client Node] -- Request (Service Type) --> ServiceA[/robot/perform_task]
    ServiceA -- Response (Service Type) --> Client

    ServiceA --> Server[Service Server Node]
    Server --> RobotAction[Execute Robot Task]
    RobotAction --> Server
```

### Comparison: Topics vs. Services

| Feature           | ROS 2 Topics                                  | ROS 2 Services                                  |
|-------------------|-----------------------------------------------|-------------------------------------------------|
| **Communication** | Asynchronous, one-to-many (publish-subscribe) | Synchronous, one-to-one (request-response)      |
| **Data Flow**     | Continuous stream of data                     | Single request, single response                 |
| **Use Case**      | Sensor data, odometry, velocity commands      | Triggering actions, querying state, calculations|
| **Blocking**      | Non-blocking                                  | Client blocks until response                    |

üéì **Key Insight: Designing Effective Service Definitions**

The effectiveness of a ROS 2 service heavily depends on its *service definition*. A well-designed service type, encompassing a clear request structure and a comprehensive response structure, minimizes ambiguity and maximizes reusability. When defining a service, it's important to consider:

-   **Granularity**: Should the service perform a single, atomic operation (e.g., `get_battery_level`) or a more complex sequence (e.g., `perform_pick_and_place`)? Smaller, more atomic services are often easier to test and combine.
-   **Error Handling**: The response should include status indicators (e.g., success/failure boolean) and detailed error messages to inform the client about the outcome of the request.
-   **Idempotency**: Can the service be called multiple times with the same request without causing unintended side effects? Designing for idempotency improves robustness.
-   **Payload**: The request and response messages should contain all necessary information without being overly verbose or containing redundant data.

For humanoid robots, services are invaluable for orchestrating high-level tasks. For example, an AI planner might use a `navigate_to_pose` service, expecting a clear success or failure response before planning the next step. Well-defined service interfaces are crucial for complex, multi-component robot behaviors.

### Code Example: Simple ROS 2 Python Service (Server)

This Python code defines a basic ROS 2 service server that adds two integers. This requires a custom service definition.

```python
# File: ros2_ws/src/simple_service_pkg/simple_service_pkg/add_two_ints_server.py

import rclpy
from rclpy.node import Node

# Import the custom service type (will be generated by ROS 2 build system)
from example_interfaces.srv import AddTwoInts

class AddTwoIntsServiceServer(Node):

    def __init__(self):
        super().__init__('add_two_ints_server')
        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)
        self.get_logger().info('AddTwoInts Service Server started.')

    def add_two_ints_callback(self, request, response):
        response.sum = request.a + request.b
        self.get_logger().info(f'Incoming request: a={request.a}, b={request.b}')
        self.get_logger().info(f'Sending response: sum={response.sum}')
        return response

def main(args=None):
    rclpy.init(args=args)
    add_two_ints_server = AddTwoIntsServiceServer()
    rclpy.spin(add_two_ints_server)
    add_two_ints_server.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

To run this code:
1.  Define the service in `ros2_ws/src/simple_service_pkg/srv/AddTwoInts.srv`:
    ```
    int64 a
    int64 b
    ---
    int64 sum
    ```
2.  Update `ros2_ws/src/simple_service_pkg/package.xml` and `CMakeLists.txt` to build the service.
3.  Build your ROS 2 workspace.
4.  Source your ROS 2 environment.
5.  Run: `ros2 run simple_service_pkg add_two_ints_server`

This server will wait for incoming requests to add two integers.

ü§ù **Practice: Triggering a Simulated Service via FastAPI**

Our FastAPI backend can act as a bridge, allowing web clients or other AI components to trigger ROS 2 services indirectly. This practice exercise involves simulating a `curl` command to send a request to a conceptual ROS 2 service via our backend, demonstrating how an external system can initiate synchronous robot behaviors.

### `curl` Example: Calling Simulated `AddTwoInts` Service

Assume our FastAPI backend (`backend/main.py`) has an endpoint `/ros2/service/add_ints` that takes two integers as query parameters and calls a simulated `AddTwoInts` ROS 2 service.

```bash
# Placeholder curl command - replace with actual FastAPI endpoint once ready
# Ensure your FastAPI backend (backend/main.py) is running (e.g., uvicorn main:app --reload)

curl -X GET \\
  "http://127.0.0.1:8000/ros2/service/add_ints?a=5&b=7" \\
  -H "Content-Type: application/json"
```

**Expected (Simulated) FastAPI Response:**

```json
{
  "status": "success",
  "service_name": "add_two_ints",
  "request": {"a": 5, "b": 7},
  "response": {"sum": 12},
  "timestamp": "2025-12-07T15:00:00Z"
}
```

This `curl` command demonstrates how a client can use FastAPI to interact with a ROS 2 service. In a real implementation, the FastAPI endpoint would create a `ServiceClient` (using `rclpy.create_client`), send the request, and wait for the response from the actual ROS 2 service server. This provides a powerful way to integrate web-based control or AI decision-making with specific, synchronous robot functionalities.

Ask your AI: Implement a new FastAPI endpoint `/ros2/service/add_ints` in `backend/main.py` that takes `a` and `b` as query parameters. It should simulate the `AddTwoInts` service call and return the simulated JSON response, including appropriate Pydantic models for the response.